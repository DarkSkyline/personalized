<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Usage of the Personalized Package • personalized</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/cerulean/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">personalized</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../articles/usage_of_the_personalized_package.html">Vignette</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Usage of the Personalized Package</h1>
                        <h4 class="author">Jared Huling</h4>
            
            <h4 class="date">2017-09-22</h4>
          </div>

    
    
<div class="contents">
<div id="introduction-to-personalized" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction-to-personalized" class="anchor"></a>Introduction to <code>personalized</code>
</h1>
<p>The <code>personalized</code> package aims to provide an entire analysis pipeline that encompasses a broad class of statistical methods for subgroup identification / personalized medicine.</p>
<p>The general analysis pipeline is as follows:</p>
<ol style="list-style-type: decimal">
<li>Construct propensity score function and check propensity score diagnostics</li>
<li>Choose and fit a subgroup identification model</li>
<li>Estimate the resulting treatment effects among estimated subgroups</li>
<li>Visualize and examine model and subgroup treatment effects</li>
</ol>
<p>The available subgroup identification models are those under the purview of the general subgroup identification framework proposed by Chen, et al. (2017). In this section we will give a brief summary of this framework and what elements of it are available in the <code>personalized</code> package.</p>
<p>In general we are interested in understanding the impact of a treatment on an outcome and in particular determining if and how different patients respond differently to a treatment in terms of their expected outcome. Assume the outcome we observe <span class="math inline">\(Y\)</span> is such that larger values are preferable. In addition to the outcome, we also observe patient covariate information <span class="math inline">\(X \in \mathbb{R}^p\)</span> and the treatment status <span class="math inline">\(T \in \{-1,1\}\)</span>, where <span class="math inline">\(T = 1\)</span> indicates that a patient received the treatment, and <span class="math inline">\(T = -1\)</span> indicates a patient received the control. For the purposes of this package, we assume that the expected outcome conditional on the covariate and treatment status information can be represented by <span class="math display">\[E(Y|X, T) = g(X) + T\Delta(X).\]</span> Here, <span class="math inline">\(\Delta(X)\)</span> represents the interaction between treatment and covariates and <span class="math inline">\(g(X)\)</span> represents the main effects of the patient covariate information on the outcome.</p>
<p>We call the term <span class="math inline">\(\Delta(X)\)</span> a benefit score, as it reflects how much a patient is expected to benefit from a treatment in terms of their outcome. For a patient with <span class="math inline">\(X = x\)</span>, if <span class="math inline">\(\Delta(x) &gt; 0\)</span> (assuming larger outcomes are better), the treatment is beneficial in terms of the expected outcome, and if <span class="math inline">\(\Delta(X) \leq 0\)</span>, the control is better than the treatment. Hence to identify which subgroup of patients benefits from a treatment, we seek to estimate <span class="math inline">\(\Delta(X)\)</span>.</p>
<p>In the framework of Chen, et al. (2017), there are two main methods for estimating subgroups. The first is called the weighting method. The weighting method estimates <span class="math inline">\(\Delta(X)\)</span> by minimizing the following objective function with respect to <span class="math inline">\(f(X)\)</span>: <span class="math display">\[L_W(f) = \frac{1}{n}\sum_{i = 1}^n\frac{M(Y_i, T_i\times f(x_i)) }{ {T_i\pi(x_i)+(1-T_i)/2} },\]</span> where <span class="math inline">\(\pi(x) = Pr(T = 1|X = x)\)</span> is the propensity score function. Here, <span class="math inline">\(\hat{f}\)</span> is our estimated benefit score. Hence <span class="math inline">\(\hat{f} = \mbox{argmin}_f L_W(f)\)</span> is our estimate of <span class="math inline">\(\Delta(X)\)</span>. If we want a simple functional form for the estimate <span class="math inline">\(\hat{f}\)</span>, we can restrict the form of <span class="math inline">\(f\)</span> such that it is a linear combination of the covariates, i.e. <span class="math inline">\(f(X) = X^T\beta\)</span>. Hence <span class="math inline">\(\hat{f}(X) = X^T\hat{\beta}\)</span>.</p>
<p>The A-learning estimator is the minimizer of <span class="math display">\[L_A(f) = \frac{1}{n}\sum_{i = 1}^n M(Y_i, {\{(T_i+1)/2 -\pi(x_i)\} } {\times f(x_i))}.\]</span></p>
<div id="choice-of-m-function" class="section level3">
<h3 class="hasAnchor">
<a href="#choice-of-m-function" class="anchor"></a>Choice of <span class="math inline">\(M\)</span> function</h3>
<p>The <code>personalized</code> package offers a flexible range of choices both for the form of <span class="math inline">\(f(X)\)</span> and also for the loss function <span class="math inline">\(M(y, v)\)</span>. Every choice of <span class="math inline">\(f\)</span> and <span class="math inline">\(M\)</span> can be used for either the weighting method or for the A-learning method. In this package, we limit the use of <span class="math inline">\(M\)</span> to natural choices corresponding to the type of outcome. For example, the squared error loss <span class="math inline">\(M(y, v) = (v - y) ^ 2\)</span> corresponds to continuous responses; the logistic loss <span class="math inline">\(M(y, v) = y \cdot log(1 + \exp\{-v\})\)</span> corresponds to binary outcomes, and the loss associated with the negative partial likelihood of the Cox proportional hazards model corresponds to time-to-event outcomes.</p>
</div>
<div id="choice-of-f" class="section level3">
<h3 class="hasAnchor">
<a href="#choice-of-f" class="anchor"></a>Choice of <span class="math inline">\(f\)</span>
</h3>
<p>The choices of <span class="math inline">\(f\)</span> offered in the <code>personalized</code> package are varied. A familiar, interpretable choice of <span class="math inline">\(f(X)\)</span> is <span class="math inline">\(X^T\beta\)</span>. Also offered is an additive model, i.e. <span class="math inline">\(f(X) = \sum_{j = 1}^pf_j(X_j)\)</span>; this option is accessed through use of the <code>mgcv</code> package, which provides estimation procedures for generalized additive models (GAMs). Another flexible, but less interpretable choice offered here is related to gradient boosted decision trees, which model <span class="math inline">\(f\)</span> as <span class="math inline">\(f(X) = \sum_{k = 1}^Kf_k(X)\)</span>, where each <span class="math inline">\(f_k\)</span> is a decision tree model.</p>
</div>
<div id="variable-selection" class="section level3">
<h3 class="hasAnchor">
<a href="#variable-selection" class="anchor"></a>Variable Selection</h3>
<p>For subgroup identification models with <span class="math inline">\(f(X) = X^T\beta\)</span>, the <code>personalized</code> package also allows for variable selection. Instead of minimizing <span class="math inline">\(L_W(f)\)</span> or <span class="math inline">\(L_A(f)\)</span>, we instead minimize a penalized version: <span class="math inline">\(L_W(f) + \lambda||\beta||_1\)</span> or <span class="math inline">\(L_A(f) + \lambda||\beta||_1\)</span>.</p>
</div>
</div>
<div id="quick-usage-reference" class="section level1">
<h1 class="hasAnchor">
<a href="#quick-usage-reference" class="anchor"></a>Quick Usage Reference</h1>
<p>First simulate some data where we know the truth. In this simulation, the treatment assignment depends on covariates and hence we must model the propensity score <span class="math inline">\(\pi(x) = Pr(T = 1 | X = x)\)</span>. In this simulation we will assume that larger values of the outcome are better.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(personalized)

<span class="kw">set.seed</span>(<span class="dv">123</span>)
n.obs  &lt;-<span class="st"> </span><span class="dv">1000</span>
n.vars &lt;-<span class="st"> </span><span class="dv">50</span>
x &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(n.obs <span class="op">*</span><span class="st"> </span>n.vars, <span class="dt">sd =</span> <span class="dv">3</span>), n.obs, n.vars)

<span class="co"># simulate non-randomized treatment</span>
xbetat   &lt;-<span class="st"> </span><span class="fl">0.5</span> <span class="op">+</span><span class="st"> </span><span class="fl">0.25</span> <span class="op">*</span><span class="st"> </span>x[,<span class="dv">21</span>] <span class="op">-</span><span class="st"> </span><span class="fl">0.25</span> <span class="op">*</span><span class="st"> </span>x[,<span class="dv">41</span>]
trt.prob &lt;-<span class="st"> </span><span class="kw">exp</span>(xbetat) <span class="op">/</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(xbetat))
trt      &lt;-<span class="st"> </span><span class="kw">rbinom</span>(n.obs, <span class="dv">1</span>, <span class="dt">prob =</span> trt.prob)

<span class="co"># simulate delta</span>
delta &lt;-<span class="st"> </span>(<span class="fl">0.5</span> <span class="op">+</span><span class="st"> </span>x[,<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span><span class="fl">0.5</span> <span class="op">*</span><span class="st"> </span>x[,<span class="dv">3</span>] <span class="op">-</span><span class="st"> </span><span class="dv">1</span> <span class="op">*</span><span class="st"> </span>x[,<span class="dv">11</span>] <span class="op">+</span><span class="st"> </span><span class="dv">1</span> <span class="op">*</span><span class="st"> </span>x[,<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>x[,<span class="dv">12</span>] )

<span class="co"># simulate main effects g(X)</span>
xbeta &lt;-<span class="st"> </span>x[,<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>x[,<span class="dv">11</span>] <span class="op">-</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>x[,<span class="dv">12</span>]<span class="op">^</span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>x[,<span class="dv">13</span>] <span class="op">+</span><span class="st"> </span><span class="fl">0.5</span> <span class="op">*</span><span class="st"> </span>x[,<span class="dv">15</span>] <span class="op">^</span><span class="st"> </span><span class="dv">2</span>
xbeta &lt;-<span class="st"> </span>xbeta <span class="op">+</span><span class="st"> </span>delta <span class="op">*</span><span class="st"> </span>(<span class="dv">2</span> <span class="op">*</span><span class="st"> </span>trt <span class="op">-</span><span class="st"> </span><span class="dv">1</span>)

<span class="co"># simulate continuous outcomes</span>
y &lt;-<span class="st"> </span><span class="kw">drop</span>(xbeta) <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(n.obs)</code></pre></div>
<div id="creating-and-checking-propensity-score-model" class="section level2">
<h2 class="hasAnchor">
<a href="#creating-and-checking-propensity-score-model" class="anchor"></a>Creating and Checking Propensity Score Model</h2>
<p>The first step in our analysis is to construct a model for the propensity score. In the <code>personalized</code> package, we need to wrap this model in a function which inputs covariate values and the treatment statuses and outputs a propensity score between 0 and 1. Since there are many covariates, we use the lasso to select variables in our propensity score model:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># create function for fitting propensity score model</span>
prop.func &lt;-<span class="st"> </span><span class="cf">function</span>(x, trt)
{
 <span class="co"># fit propensity score model</span>
 propens.model &lt;-<span class="st"> </span><span class="kw">cv.glmnet</span>(<span class="dt">y =</span> trt,
                            <span class="dt">x =</span> x, 
                            <span class="dt">family =</span> <span class="st">"binomial"</span>)
 pi.x &lt;-<span class="st"> </span><span class="kw">predict</span>(propens.model, <span class="dt">s =</span> <span class="st">"lambda.min"</span>,
                 <span class="dt">newx =</span> x, <span class="dt">type =</span> <span class="st">"response"</span>)[,<span class="dv">1</span>]
 pi.x
}</code></pre></div>
<p>We then need to make sure the propensity scores have sufficient overlap between treatment groups. We can do this with the <code><a href="../reference/check.overlap.html">check.overlap()</a></code> function, which plots densities or histograms of the propensity scores for each of the treatment groups:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/check.overlap.html">check.overlap</a></span>(x, trt, prop.func)</code></pre></div>
<p><img src="usage_of_the_personalized_package_files/figure-html/plot_overlap-1.png" width="672"></p>
<p>We can see that our propensity scores have common support.</p>
</div>
<div id="fitting-subgroup-identification-model" class="section level2">
<h2 class="hasAnchor">
<a href="#fitting-subgroup-identification-model" class="anchor"></a>Fitting Subgroup Identification Model</h2>
<p>The next step is to choose and fit a subgroup identification model. In this example, the outcome is continuous, so we choose the squared error loss function. We also choose the model type (either the weighting or the A-learning method). The main function for fitting subgroup identification models is <code>fit.subgroup</code>. Since there are many covariates, we choose a loss function with a lasso penalty to select variables. The underlying fitting function here is <code>cv.glmnet()</code>. We can pass to <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code> arguments of the <code>cv.glmnet()</code> function, such as <code>nfolds</code> for the number of cross validation folds.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">subgrp.model &lt;-<span class="st"> </span><span class="kw"><a href="../reference/fit.subgroup.html">fit.subgroup</a></span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y,
                             <span class="dt">trt =</span> trt,
                             <span class="dt">propensity.func =</span> prop.func,
                             <span class="dt">loss   =</span> <span class="st">"sq_loss_lasso"</span>,
                             <span class="dt">nfolds =</span> <span class="dv">10</span>)              <span class="co"># option for cv.glmnet</span>

<span class="kw">summary</span>(subgrp.model)</code></pre></div>
<pre><code>## family:  gaussian 
## loss:    sq_loss_lasso 
## method:  weighting 
## 
## Average Outcomes:
##                 Recommended 0      Recommended 1
## Received 0  -9.1948 (n = 190) -16.1668 (n = 220)
## Received 1 -18.8823 (n = 272)  -8.3777 (n = 318)
## 
## 0 effect among recommended 0 1 effect among recommended 1 
##             9.6875 (n = 462)             7.7892 (n = 538) 
## 
## Benefit score quantiles: 
##       0%      25%      50%      75%     100% 
## -10.9672  -1.8897   0.3569   2.2806  10.0196 
## 
## 8 out of 51 variables selected in total by the lasso (cross validation criterion).
## 
##     Estimate
## 1     0.2231
## V1    0.0577
## V2    0.6558
## V3   -0.4550
## V6   -0.1070
## V11  -0.4036
## V13   0.3108
## V17   0.2491
## V37  -0.1768</code></pre>
<p>We can then plot the outcomes of patients in the different subgroups:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(subgrp.model)</code></pre></div>
<p><img src="usage_of_the_personalized_package_files/figure-html/plot_model-1.png" width="672"></p>
<p>Alternatively, we can create an interaction plot. This plot represents the average outcome within each subgroup broken down by treatment status. If the lines in the interaction plots cross, that indicates there is a subgroup treatment effect.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(subgrp.model, <span class="dt">type =</span> <span class="st">"interaction"</span>)</code></pre></div>
<p><img src="usage_of_the_personalized_package_files/figure-html/plot_model_2-1.png" width="672"></p>
</div>
<div id="evaluating-effect-of-subgroup-identification-model" class="section level2">
<h2 class="hasAnchor">
<a href="#evaluating-effect-of-subgroup-identification-model" class="anchor"></a>Evaluating Effect of Subgroup Identification Model</h2>
<p>Unfortunately, if we simply look at the average outcome within each subgroup, this will give us a biased estimate of the treatment effects within each subgroup as we have already used the data to estimate the subgroups. Instead, to get a valid estimate of the subgroup treatment effects we can use a bootstrap approach to correcting for this bias. We can alternatively repeatedly partition our data into training and testing samples. In this procedure for each replication we fit a subgroup model using the training data and then evaluate the subgroup treatment effects on the testing data. The argument <code>B</code> specifies the number of replications and the argument <code>train.fraction</code> specifies what proportion of samples are for training in the training and testing partitioning method.</p>
<p>Both of these approaches can be carried out using the <code><a href="../reference/validate.subgroup.html">validate.subgroup()</a></code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">validation &lt;-<span class="st"> </span><span class="kw"><a href="../reference/validate.subgroup.html">validate.subgroup</a></span>(subgrp.model, 
                                <span class="dt">B =</span> 25L,  <span class="co"># specify the number of replications</span>
                                <span class="dt">method =</span> <span class="st">"training_test_replication"</span>,
                                <span class="dt">train.fraction =</span> <span class="fl">0.75</span>)

validation</code></pre></div>
<pre><code>## family:  gaussian 
## loss:    sq_loss_lasso 
## method:  weighting 
## 
## validation method:  training_test_replication 
## iterations:  25 
## 
## Average Test Set Outcomes:
##                                Recommended 0
## Received 0 -11.3604 (SE = 4.0024, n = 49.92)
## Received 1 -15.7901 (SE = 2.6433, n = 74.44)
##                                Recommended 1
## Received 0 -14.4965 (SE = 2.3852, n = 50.44)
## Received 1  -10.2652 (SE = 3.4167, n = 75.2)
## 
##     0 effect among recommended 0     1 effect among recommended 1 
## 4.4297 (SE = 4.9129, n = 124.36) 4.2312 (SE = 4.7051, n = 125.64)</code></pre>
<p>We can then plot the average outcomes averaged over all replications of the training and testing partition procedure:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(validation)</code></pre></div>
<pre><code>## Warning: Removed 4 rows containing non-finite values (stat_boxplot).</code></pre>
<p><img src="usage_of_the_personalized_package_files/figure-html/plot_validation-1.png" width="672"> From the above plot we can evaluate what the impact of the subgroups is. Among patients for whom the model recommends the control is more effective than the treatment, we can see that those who instead take the treatment are worse off than patients who take the control. Similarly, among patients who are recommended the treatment, patients who take the treatment are better off on average than patients who do not take the treatment.</p>
<p>Similarly, we can create an interaction plot of either the bootstrap bias-corrected means within the different subgroups or the average test set means within subgroups. Here, lines crossing is an indicator of differential treatment effect between the subgroups.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(validation, <span class="dt">type =</span> <span class="st">"interaction"</span>)</code></pre></div>
<p><img src="usage_of_the_personalized_package_files/figure-html/plot_validation_2-1.png" width="672"></p>
<p>We can also compare the validation results with the results on the observed data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plotCompare.html">plotCompare</a></span>(subgrp.model, validation, <span class="dt">type =</span> <span class="st">"interaction"</span>)</code></pre></div>
<p><img src="usage_of_the_personalized_package_files/figure-html/plot_validation_compare-1.png" width="672"></p>
<p>Note that the estimated treatment effects within subgroups are attenuated for the validated results. It is common for the estimated treatment effects within subgroups to be overly-optimistic based on the training data.</p>
</div>
</div>
<div id="user-guide" class="section level1">
<h1 class="hasAnchor">
<a href="#user-guide" class="anchor"></a>User Guide</h1>
<div id="overview" class="section level2">
<h2 class="hasAnchor">
<a href="#overview" class="anchor"></a>Overview</h2>
<p>In this user guide we will provide more detailed information about the entire subgroup identification modeling process in the <code>personalized</code> package. Specifically, we will explore more thoroughly the four steps outlined in the introduction section.</p>
</div>
<div id="creating-and-checking-a-propensity-score-model" class="section level2">
<h2 class="hasAnchor">
<a href="#creating-and-checking-a-propensity-score-model" class="anchor"></a>Creating and Checking a propensity Score Model</h2>
<p>The propensity score, <span class="math inline">\(\pi(x) = Pr(T = 1 | X = x)\)</span> is a crucial component of the subgroup identification models in the <code>personalized</code> package, especially for the analysis of data that comes from an observational study.</p>
<div id="observational-studies" class="section level3">
<h3 class="hasAnchor">
<a href="#observational-studies" class="anchor"></a>Observational Studies</h3>
<p>For data from observational studies, the user must construct a model for the propensity score. Typically this is done usine a logistic regression model with</p>
<p><span class="math display">\[ \mbox{logit}(\pi(X)) = \mbox{logit} Pr(T = 1 | X) = X^T\beta.\]</span> When this model is not appropriate, users may use a more flexible model, or utilize variable selection techniques if there are a large number of covariates. More details on how this is implemented are documented within the <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code> documentation below.</p>
</div>
<div id="randomized-controlled-trials" class="section level3">
<h3 class="hasAnchor">
<a href="#randomized-controlled-trials" class="anchor"></a>Randomized Controlled Trials</h3>
<p>For data from RCTs, the users can simply use a constant function for the propensity score. For example, if patients were equally randomized to the treatment and control groups, we know that <span class="math inline">\(\pi(x) = 1/2\)</span>.</p>
</div>
</div>
<div id="fitting-subgroup-identification-models" class="section level2">
<h2 class="hasAnchor">
<a href="#fitting-subgroup-identification-models" class="anchor"></a>Fitting Subgroup Identification Models</h2>
<div id="overview-1" class="section level3">
<h3 class="hasAnchor">
<a href="#overview-1" class="anchor"></a>Overview</h3>
<p>The core component of the <code>personalized</code> package is in fitting subgroup identification models with the <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code> function. This function provides fitting capabilities for many different outcomes, choices of loss function, choice of underlying model for <span class="math inline">\(\Delta(X)\)</span>, and model class (either the weighting method or A-learning).</p>
</div>
<div id="explanation-of-major-function-arguments" class="section level3">
<h3 class="hasAnchor">
<a href="#explanation-of-major-function-arguments" class="anchor"></a>Explanation of Major Function Arguments</h3>
<div id="x" class="section level4">
<h4 class="hasAnchor">
<a href="#x" class="anchor"></a><code>x</code>
</h4>
<p>The argument <code>x</code> is for the design matrix. Each column of <code>x</code> corresponds to a variable to be used in the model for <span class="math inline">\(\Delta(X)\)</span> and each row of <code>x</code> corresponds to an observation. Every variable in <code>x</code> will be used for the subgroup identification model (however some variables may be removed if a variable selection procedure is specified for <code>loss</code>).</p>
</div>
<div id="y" class="section level4">
<h4 class="hasAnchor">
<a href="#y" class="anchor"></a><code>y</code>
</h4>
<p>The argument <code>y</code> is for the response vector. Each element in <code>y</code> is a patient observation. In the case of time-to-event outcomes <code>y</code> should be specified as a <code>Surv</code> object. For example the user should specify <code>y = Surv(time, status)</code>, where <code>time</code> is the observed time and <code>status</code> is an indicator that the observed time is the survival time.</p>
</div>
<div id="trt" class="section level4">
<h4 class="hasAnchor">
<a href="#trt" class="anchor"></a><code>trt</code>
</h4>
<p>The argument <code>trt</code> corresponds to the vector of observed treatment statuses. Each element in <code>trt</code> shoulld be either the integer 1 or the integer 0, where 1 in the <span class="math inline">\(i\)</span>th position means means patient <span class="math inline">\(i\)</span> received the treatment and 0 in the <span class="math inline">\(i\)</span>th position indicates patient <span class="math inline">\(i\)</span> did not receive treatment.</p>
</div>
<div id="propensity-func" class="section level4">
<h4 class="hasAnchor">
<a href="#propensity-func" class="anchor"></a><code>propensity.func</code>
</h4>
<p>The argument <code>propensity.func</code> corresponds to a function which returns a propensity score. While it seems cumbersome to have to specify a function instead of a vector of probabilities, it is crucial for later validation for the propensity scores to be re-estimated using the resampled or sampled data (this will be explained further in the section below for the <code><a href="../reference/validate.subgroup.html">validate.subgroup()</a></code> function). The user should specify a function which inputs two arguments: <code>trt</code> and <code>x</code>, where <code>trt</code> corresponds to the <code>trt</code> argument for the <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code> function and <code>x</code> corresponds to the <code>x</code> argument for the <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code> function. The function supplied to <code>propensity.func</code> should contain code that uses <code>x</code> and <code>trt</code> to fit a propensity score model and then return an estimated propensity score for each observation in <code>x</code>. A basic example which uses ` logistic regression model to estimate the propensity score is the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">propensity.func &lt;-<span class="st"> </span><span class="cf">function</span>(x, trt)
{
    <span class="co"># save data in a data.frame</span>
    data.fr &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">trt =</span> trt, x)
    
    <span class="co"># fit propensity score model</span>
    propensity.model &lt;-<span class="st"> </span><span class="kw">glm</span>(trt <span class="op">~</span><span class="st"> </span>., <span class="dt">family =</span> <span class="kw">binomial</span>(), <span class="dt">data =</span> data.fr)
    
    <span class="co"># create estimated probabilities</span>
    pi.x &lt;-<span class="st"> </span><span class="kw">predict</span>(propensity.model, <span class="dt">type =</span> <span class="st">"response"</span>)
    <span class="kw">return</span>(pi.x)
}

<span class="kw">propensity.func</span>(x, trt)[<span class="dv">101</span><span class="op">:</span><span class="dv">105</span>]</code></pre></div>
<pre><code>##       101       102       103       104       105 
## 0.2251357 0.2786683 0.9021204 0.4400091 0.8250830</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">trt[<span class="dv">101</span><span class="op">:</span><span class="dv">105</span>]</code></pre></div>
<pre><code>## [1] 0 0 1 1 1</code></pre>
<p>For randomized controlled trials with equal probability of assignment to treatment and control, the user can simply define <code>propensity.func</code> as:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">propensity.func &lt;-<span class="st"> </span><span class="cf">function</span>(x, trt) <span class="fl">0.5</span></code></pre></div>
<p>which always returns the constant <span class="math inline">\(1/2\)</span>.</p>
</div>
<div id="loss" class="section level4">
<h4 class="hasAnchor">
<a href="#loss" class="anchor"></a><code>loss</code>
</h4>
<p>The <code>loss</code> argument specifies the combination of <span class="math inline">\(M\)</span> function (i.e. loss function) and underlying model for <span class="math inline">\(f(X)\)</span>, the form of the estimator of <span class="math inline">\(\Delta(X)\)</span>. The name of each possible value for <code>loss</code> has two parts:</p>
<ol style="list-style-type: decimal">
<li>The first part, which corresponds to the <span class="math inline">\(M\)</span> function</li>
<li>The second part, which corresponds to the form of <span class="math inline">\(f(X)\)</span> and whether variable selection via the lasso is used</li>
</ol>
<p>An example is <code>sq_loss_lasso</code>, which corresponds to using <span class="math inline">\(M(y, v) = (y - v) ^ 2\)</span>, a linear form of <span class="math inline">\(f\)</span>, i.e. <span class="math inline">\(f(X) = X^T\beta\)</span>, and an additional penalty term <span class="math inline">\(\sum_{j = 1}^p|\beta_j|\)</span> added to the loss function for variable selection. Other forms of <span class="math inline">\(M\)</span> are <code>logistic_loss</code>, which corresponds to the negative log-likelihood for a logistic regression model, and <code>cox_loss</code>, which corresponds to the negative log-likelihood for the Cox proportional hazards model, <code>abs_loss</code> for <span class="math inline">\(M(y, v) = |y - v|\)</span>, and <code>huberized_loss</code> for a huberized hinge loss <span class="math inline">\(M(y, v) = (1 - yv) ^ 2/(2\delta)I(1 - \delta &lt; yv \leq 1) + (1 - yv - \delta/2)I(yv \leq 1 - \delta)\)</span> for binary outcomes.</p>
<p>All options containing <code>lasso</code> in the name use the <code>cv.glmnet()</code> function of the <code>glmnet</code> package for the underlying model fitting and variable selection. Please see the documentation of <code>cv.glmnet()</code> for information about other arguments which can be passed to it.</p>
<p>Any options for <code>loss</code> which end with <code>lasso_gam</code> have a two-stage model. Variables are selected using a linear or generalized linear model in the first stage and then the selected variables are used in a generalized additive model in the second stage. Univariate nonparametric smoother terms are used in the second stage for all continuous variables. Binary variables are used as linear terms in the model. All <code>loss</code> options containing <code>gam</code> in the name use the <code>gam()</code> function of the <code>R</code> package <code>mgcv</code>. Please see the documentation of <code>gam()</code> for information about other arguments which can be passed to it.</p>
<p>All options that end in <code>gbm</code> use a gradient-boosted decision tree model for <span class="math inline">\(f(X)\)</span>. These models are machine learning models which can provide more flexible estimation. These models are essentially a sum of many decision trees models. However, this procedure results in a “black box” model which may be more challenging or impossible to interpret. The <code>gbm</code>-based models are fit using the <code>gbm</code> <code>R</code> package. Please see the documentation for the <code>gbm</code> function of the <code>gbm</code> package for more details on the possible arguments. Tuning the values of the hyperparameters <code>shrinkage</code>, <code>n.trees</code>, and <code>interaction.depth</code> is crucial for a successful gradient-boosting model. These arguments can be passed to the <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code> function. By default, when <code>gbm</code>-based models are used, a plot of the cross validation error versus the number of trees is displayed. If this plot has values which are still decreasing significantly by the maximum value of the number of trees, then it is recommended to either increase the number of trees (<code>n.trees</code>), the maximum tree depth (<code>interaction.depth</code>), or increase the step size of the algorithm (<code>shrinkage</code>).</p>
</div>
<div id="method" class="section level4">
<h4 class="hasAnchor">
<a href="#method" class="anchor"></a><code>method</code>
</h4>
<p>The <code>method</code> argument is used to specify whether the weighting or A-learning model is used. Specify <code>'weighting'</code> for the weighting method and specify <code>'a_learning'</code> for the A-learning method.</p>
</div>
<div id="larger-outcome-better" class="section level4">
<h4 class="hasAnchor">
<a href="#larger-outcome-better" class="anchor"></a><code>larger.outcome.better</code>
</h4>
<p>The argument <code>larger.outcome.better</code> is a boolean variable indicating whether larger values of the outcome are better or preferred. If <code>larger.outcome.better = TRUE</code>, then <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code> will seek to estimate subgroups in a way that maximizes the population average outcome and if <code>larger.outcome.better = FALSE</code>, <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code> will seek to minimize the population average outcome.</p>
</div>
<div id="cutpoint" class="section level4">
<h4 class="hasAnchor">
<a href="#cutpoint" class="anchor"></a><code>cutpoint</code>
</h4>
<p>The cutpoint is the value of the benefit score (i.e. <span class="math inline">\(f(X)\)</span>) above which patients will be recommended the treatment. In other words for outcomes where larger values are better and a cutpoint with value <span class="math inline">\(c\)</span> if <span class="math inline">\(f(x) &gt; c\)</span> for a patient with covariate values <span class="math inline">\(X = x\)</span>, then they will be recommended to have the treatment instead of recommended the control. If lower values are better for the outcome, <span class="math inline">\(c\)</span> will be the value below which patients will be recommended the treatment (i.e. a patient will be recommended the treatment if <span class="math inline">\(f(x) &lt; c\)</span>). By default, the cutpoint is the population-average optimal value of 0. However, users may wish to increase this value if there are limited resources for treatment allocation.</p>
</div>
<div id="retcall" class="section level4">
<h4 class="hasAnchor">
<a href="#retcall" class="anchor"></a><code>retcall</code>
</h4>
<p>The argument <code>retcall</code> is a boolean variable which indicates whether to return the arguments passed to <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code>. It must be set to <code>TRUE</code> if the user wishes to later validate the fitted model object from <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code> using the <code><a href="../reference/validate.subgroup.html">validate.subgroup()</a></code> function. This is necessary because when <code>retcall = TRUE</code>, the design matrix <code>x</code>, response <code>y</code>, and treatment vector <code>trt</code> must be re-sampled in either the bootstrap procedure or training and testing resampling procedure of <code><a href="../reference/validate.subgroup.html">validate.subgroup()</a></code>. The only time when <code>retcall</code> should be set to <code>FALSE</code> is when the design matrix is too big to be stored in the fitted model object.</p>
</div>
<div id="section" class="section level4">
<h4 class="hasAnchor">
<a href="#section" class="anchor"></a><code>...</code>
</h4>
<p>The argument <code>...</code> is used to pass arguments to the underlying modeling functions. For example, if the lasso is specified to be used in the <code>loss</code> argument, <code>...</code> is used to pass arguments to the <code>cv.glmnet()</code> function from the <code>glmnet</code> <code>R</code> package. If <code>gam</code> is present in the name for the <code>loss</code> argument, the underlying model is fit using the <code>gam()</code> function of <code>mgcv</code>, so arguments to <code>gam()</code> can be passed using <code>...</code>. The only tricky part for <code>gam()</code> is that it also has an argument titled <code>method</code> and hence instead, to change the <code>method</code> argument of <code>gam()</code>, the user can pass values using <code>method.gam</code> which will then be passed as the argument for <code>method</code> in the <code>gam()</code> function.</p>
</div>
</div>
<div id="continuous-outcomes" class="section level3">
<h3 class="hasAnchor">
<a href="#continuous-outcomes" class="anchor"></a>Continuous Outcomes</h3>
<p>The <code>loss</code> argument options that are available for continuous outcomes are:</p>
<ul>
<li><code>'sq_loss_lasso'</code></li>
<li><code>'sq_loss_lasso_gam'</code></li>
<li><code>'sq_loss_gam'</code></li>
<li><code>'sq_loss_gbm'</code></li>
<li><code>'abs_loss_gbm'</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">subgrp.model2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/fit.subgroup.html">fit.subgroup</a></span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y,
                             <span class="dt">trt =</span> trt,
                             <span class="dt">propensity.func =</span> prop.func,
                             <span class="dt">loss   =</span> <span class="st">"sq_loss_lasso_gam"</span>,
                             <span class="dt">nfolds =</span> <span class="dv">10</span>)              <span class="co"># option for cv.glmnet</span>

<span class="kw">summary</span>(subgrp.model2)</code></pre></div>
<pre><code>## family:  gaussian 
## loss:    sq_loss_lasso_gam 
## method:  weighting 
## 
## Average Outcomes:
##                 Recommended 0      Recommended 1
## Received 0 -10.0544 (n = 196) -15.5749 (n = 214)
## Received 1   -19.01 (n = 287)  -7.7367 (n = 303)
## 
## 0 effect among recommended 0 1 effect among recommended 1 
##             8.9555 (n = 483)             7.8382 (n = 517) 
## 
## Benefit score quantiles: 
##       0%      25%      50%      75%     100% 
## -22.7092  -3.7699   0.3613   4.3515  25.8226</code></pre>
<pre><code>## 
## Family: gaussian 
## Link function: identity 
## 
## Formula:
## y ~ -1 + 1 + s(V2) + s(V3) + s(V11) + s(V13) + s(V17) + s(V37)
## 
## Approximate significance of smooth terms:
##          edf Ref.df     F  p-value    
## s(V2)  3.080  3.923 5.051 0.000501 ***
## s(V3)  1.000  1.000 8.807 0.003072 ** 
## s(V11) 6.615  7.777 1.945 0.044006 *  
## s(V13) 1.000  1.000 5.134 0.023671 *  
## s(V17) 1.000  1.000 2.146 0.143285    
## s(V37) 1.000  1.000 3.321 0.068718 .  
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## R-sq.(adj) =  0.0491   Deviance explained = 6.01%
## GCV =   1520  Scale est. = 1499.2    n = 1000</code></pre>
</div>
<div id="binary-outcomes" class="section level3">
<h3 class="hasAnchor">
<a href="#binary-outcomes" class="anchor"></a>Binary Outcomes</h3>
<p>The <code>loss</code> argument options that are available for binary outcomes are:</p>
<ul>
<li><code>'logistic_loss_lasso'</code></li>
<li><code>'logistic_loss_lasso_gam'</code></li>
<li><code>'logistic_loss_gam'</code></li>
<li><code>'huberized_loss_gbm'</code></li>
<li><code>'logistic_loss_gbm'</code></li>
</ul>
<p>Note that all options that are available for continuous options can also potentially be used for binary outcomes.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># create binary outcomes</span>
y.binary &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">*</span><span class="st"> </span>(xbeta <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(n.obs, <span class="dt">sd =</span> <span class="dv">2</span>) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> )</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">subgrp.bin &lt;-<span class="st"> </span><span class="kw"><a href="../reference/fit.subgroup.html">fit.subgroup</a></span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y.binary,
                           <span class="dt">trt =</span> trt,
                           <span class="dt">propensity.func =</span> prop.func,
                           <span class="dt">loss   =</span> <span class="st">"logistic_loss_lasso"</span>,
                           <span class="dt">nfolds =</span> <span class="dv">10</span>)      <span class="co"># option for cv.glmnet</span></code></pre></div>
<p>When gradient-boosted decision trees are used for <span class="math inline">\(f(X)\)</span> by the package <code>gbm</code>, care must be taken to choose the hyperparameters effectively. Specifically, <code>shrinkage</code> (similar to the step-size in gradient descent), <code>n.trees</code> (the number of trees to fit), and <code>interaction.depth</code> (the maximum depth of each tree) should be tuned according to the data at hand. By default for gradient-boosting models, <code>fit.subgroup</code> plots the cross validation error versus the number of trees to give the user a sense of if their choice of tuning parameters is effective.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">subgrp.bin2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/fit.subgroup.html">fit.subgroup</a></span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y.binary,
                            <span class="dt">trt =</span> trt,
                            <span class="dt">propensity.func =</span> prop.func,
                            <span class="dt">loss =</span> <span class="st">"logistic_loss_gbm"</span>,
                            <span class="dt">shrinkage =</span> <span class="fl">0.025</span>,  <span class="co"># options for gbm</span>
                            <span class="dt">n.trees =</span> <span class="dv">1500</span>,
                            <span class="dt">interaction.depth =</span> <span class="dv">3</span>,
                            <span class="dt">cv.folds =</span> <span class="dv">5</span>)</code></pre></div>
<p>We can see that at least on the training data, the performance of the gradient-boosting model is better.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">subgrp.bin</code></pre></div>
<pre><code>## family:  binomial 
## loss:    logistic_loss_lasso 
## method:  weighting 
## 
## Average Outcomes:
##               Recommended 0    Recommended 1
## Received 0  0.442 (n = 181) 0.2271 (n = 229)
## Received 1 0.2259 (n = 270) 0.4312 (n = 320)
## 
## 0 effect among recommended 0 1 effect among recommended 1 
##             0.2161 (n = 451)             0.2042 (n = 549) 
## 
## Benefit score quantiles: 
##       0%      25%      50%      75%     100% 
## -1.31720 -0.24199  0.06729  0.38384  1.48203</code></pre>
</div>
<div id="time-to-event-outcomes" class="section level3">
<h3 class="hasAnchor">
<a href="#time-to-event-outcomes" class="anchor"></a>Time-to-event Outcomes</h3>
<p>The <code>loss</code> argument options that are available for continuous outcomes are:</p>
<ul>
<li><code>'cox_loss_lasso'</code></li>
<li><code>'cox_loss_gbm'</code></li>
</ul>
<p>First we will generate time-to-event outcomes to illustrate usage of the <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code> model.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># create time-to-event outcomes</span>
surv.time &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span><span class="dv">20</span> <span class="op">-</span><span class="st"> </span>xbeta <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(n.obs, <span class="dt">sd =</span> <span class="dv">1</span>))
cens.time &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="kw">rnorm</span>(n.obs, <span class="dt">sd =</span> <span class="dv">3</span>))
y.time.to.event  &lt;-<span class="st"> </span><span class="kw">pmin</span>(surv.time, cens.time)
status           &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">*</span><span class="st"> </span>(surv.time <span class="op">&lt;=</span><span class="st"> </span>cens.time)</code></pre></div>
<p>For subgroup identification models for time-to-event outcomes, the user should provide <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code> with a <code>Surv</code> object for <code>y</code>. This can be done like the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(survival)
<span class="kw">set.seed</span>(<span class="dv">123</span>)
subgrp.cox &lt;-<span class="st"> </span><span class="kw"><a href="../reference/fit.subgroup.html">fit.subgroup</a></span>(<span class="dt">x =</span> x, <span class="dt">y =</span> <span class="kw"><a href="http://www.rdocumentation.org/packages/survival/topics/Surv">Surv</a></span>(y.time.to.event, status),
                           <span class="dt">trt =</span> trt,
                           <span class="dt">propensity.func =</span> prop.func,
                           <span class="dt">method =</span> <span class="st">"weighting"</span>,
                           <span class="dt">loss   =</span> <span class="st">"cox_loss_lasso"</span>,
                           <span class="dt">nfolds =</span> <span class="dv">10</span>)      <span class="co"># option for cv.glmnet</span></code></pre></div>
<p>The subgroup treatment effects are estimated using the restricted mean statistic and can be displayed with <code><a href="../reference/summary.html">summary.subgroup_fitted()</a></code> or <code><a href="../reference/print.html">print.subgroup_fitted()</a></code> like the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(subgrp.cox)</code></pre></div>
<pre><code>## family:  cox 
## loss:    cox_loss_lasso 
## method:  weighting 
## 
## Average Outcomes:
##                 Recommended 0     Recommended 1
## Received 0 494.7518 (n = 260) 47.2701 (n = 150)
## Received 1 159.1706 (n = 369) 181.626 (n = 221)
## 
## 0 effect among recommended 0 1 effect among recommended 1 
##           335.5812 (n = 629)           134.3559 (n = 371) 
## 
## Benefit score quantiles: 
##       0%      25%      50%      75%     100% 
## -0.56536 -0.17097 -0.05576  0.06300  0.63843 
## 
## 8 out of 50 variables selected in total by the lasso (cross validation criterion).
## 
##     Estimate
## 1     0.0490
## V2    0.0496
## V3   -0.0070
## V8   -0.0034
## V11  -0.0228
## V13   0.0075
## V17   0.0014
## V47  -0.0015
## V50   0.0113</code></pre>
</div>
<div id="efficiency-augmentation" class="section level3">
<h3 class="hasAnchor">
<a href="#efficiency-augmentation" class="anchor"></a>Efficiency Augmentation</h3>
<p>The <code>personalized</code> package also allows for efficiency augmentation of the subgroup identification models for continuous outcomes. The basic idea of efficiency augmentation is to construct a model for the main effects of the model and shift the outcome based on these main effects. The resulting estimator based on the shifted outcome can be more efficient than using the outcome itself.</p>
<p>In the <code>personalized</code> package, this involves providing <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code> a function which inputs the covariate information <code>x</code> and the outcomes <code>y</code> and outputs a prediction for <code>y</code> based on <code>x</code>. The following is an example of such a function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">adjustment.func &lt;-<span class="st"> </span><span class="cf">function</span>(x, y)
{
    df.x  &lt;-<span class="st"> </span><span class="kw">data.frame</span>(x)
    
    <span class="co"># add all squared terms to model</span>
    form  &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">paste</span>(<span class="st">" ~ -1 + "</span>, 
                <span class="kw">paste</span>(<span class="kw">paste</span>(<span class="st">'poly('</span>, <span class="kw">colnames</span>(df.x), <span class="st">', 2)'</span>, <span class="dt">sep=</span><span class="st">''</span>), 
                      <span class="dt">collapse=</span><span class="st">" + "</span>)))
    mm    &lt;-<span class="st"> </span><span class="kw">model.matrix</span>(<span class="kw">as.formula</span>(form), <span class="dt">data =</span> df.x)
    cvmod &lt;-<span class="st"> </span><span class="kw">cv.glmnet</span>(<span class="dt">y =</span> y, <span class="dt">x =</span> mm, <span class="dt">nfolds =</span> <span class="dv">10</span>)
    predictions &lt;-<span class="st"> </span><span class="kw">predict</span>(cvmod, <span class="dt">newx =</span> mm, <span class="dt">s =</span> <span class="st">"lambda.min"</span>)
    predictions
}</code></pre></div>
<p>Then this can be used in <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code> by passing the function to the argument <code>augment.func</code> like the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">subgrp.model.eff &lt;-<span class="st"> </span><span class="kw"><a href="../reference/fit.subgroup.html">fit.subgroup</a></span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y,
                             <span class="dt">trt =</span> trt,
                             <span class="dt">propensity.func =</span> prop.func,
                             <span class="dt">loss   =</span> <span class="st">"sq_loss_lasso"</span>,
                             <span class="dt">augment.func =</span> adjustment.func,
                             <span class="dt">nfolds =</span> <span class="dv">10</span>)              <span class="co"># option for cv.glmnet</span>

<span class="kw">summary</span>(subgrp.model.eff)</code></pre></div>
<pre><code>## family:  gaussian 
## loss:    sq_loss_lasso 
## method:  weighting 
## 
## Average Outcomes:
##                 Recommended 0      Recommended 1
## Received 0  -6.8697 (n = 202)  -18.827 (n = 208)
## Received 1 -16.0758 (n = 292) -10.4226 (n = 298)
## 
## 0 effect among recommended 0 1 effect among recommended 1 
##             9.2061 (n = 494)             8.4044 (n = 506) 
## 
## Benefit score quantiles: 
##        0%       25%       50%       75%      100% 
## -11.70152  -2.57836   0.04442   2.53750  10.44856 
## 
## 6 out of 51 variables selected in total by the lasso (cross validation criterion).
## 
##     Estimate
## 1    -0.0815
## V2    0.8629
## V3   -0.5513
## V11  -0.7276
## V20  -0.0104
## V30  -0.0367
## V47  -0.1321</code></pre>
</div>
<div id="plotting-fitted-models" class="section level3">
<h3 class="hasAnchor">
<a href="#plotting-fitted-models" class="anchor"></a>Plotting Fitted Models</h3>
<p>The outcomes (or average outcomes) of patients within different subgroups can be plotted using the <code>plot()</code> function. In particular, this function plots patient outcomes by treatment group within each subgroup of patients (those recommended the treatment by the model and those recommended the control by the model). Boxplots of the outcomes can be plotted in addition to densities and and interaction plot of the average outcomes within each of these groups. They can all be generated like the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(subgrp.model)</code></pre></div>
<p><img src="usage_of_the_personalized_package_files/figure-html/plot_ex_model_1-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(subgrp.model, <span class="dt">type =</span> <span class="st">"density"</span>)</code></pre></div>
<p><img src="usage_of_the_personalized_package_files/figure-html/plot_ex_model_2-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(subgrp.model, <span class="dt">type =</span> <span class="st">"interaction"</span>)</code></pre></div>
<p><img src="usage_of_the_personalized_package_files/figure-html/plot_ex_model_3-1.png" width="672"></p>
<p>Multiple models can be visually compared using the <code><a href="../reference/plotCompare.html">plotCompare()</a></code> function, which offers the same plotting options as the <code><a href="../reference/plot.html">plot.subgroup_fitted()</a></code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plotCompare.html">plotCompare</a></span>(subgrp.model, subgrp.model.eff)</code></pre></div>
<p><img src="usage_of_the_personalized_package_files/figure-html/plot_compare_ex2-1.png" width="672"></p>
</div>
<div id="comparing-subgroups-from-a-fitted-model" class="section level3">
<h3 class="hasAnchor">
<a href="#comparing-subgroups-from-a-fitted-model" class="anchor"></a>Comparing Subgroups from a Fitted Model</h3>
<p>The <code><a href="../reference/summarize.subgroups.html">summarize.subgroups()</a></code> function compares the means of covariate values within the estimated subgroups. P-values for the differences within subgroups are also computed. For continuous variables, the p-value will come from a t-test and for binary variables, the p-value will come from a chi-squared test.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">comp &lt;-<span class="st"> </span><span class="kw"><a href="../reference/summarize.subgroups.html">summarize.subgroups</a></span>(subgrp.model)</code></pre></div>
<p>The user can optionally print only the covariates which have significant differences between subgroups with a p-value below a given threshold like the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(comp, <span class="dt">p.value =</span> <span class="fl">0.01</span>)</code></pre></div>
<pre><code>##     Avg (recom 0) Avg (recom 1)   0 - 1 pval 0 - 1 SE (recom 0)
## V1        -0.3561       0.39572 -0.7518  6.564e-05       0.1386
## V2        -1.5303       1.55092 -3.0812  2.128e-66       0.1211
## V3         1.0502      -1.01400  2.0642  1.650e-30       0.1246
## V6         0.4025      -0.15338  0.5559  3.241e-03       0.1405
## V11        1.2063      -0.89040  2.0967  1.095e-29       0.1300
## V13       -0.9325       0.44922 -1.3818  2.738e-13       0.1358
## V14       -0.1832       0.35552 -0.5387  4.690e-03       0.1399
## V17       -0.8114       0.40915 -1.2206  1.618e-10       0.1328
## V19        0.1809      -0.30860  0.4895  8.898e-03       0.1361
## V27       -0.3318       0.08996 -0.4217  2.399e-02       0.1382
## V33        0.2442      -0.22611  0.4703  1.176e-02       0.1351
## V37        0.5381      -0.52638  1.0645  2.390e-08       0.1376
## V45        0.1902      -0.22873  0.4189  3.011e-02       0.1415
##     SE (recom 1)
## V1        0.1263
## V2        0.1129
## V3        0.1212
## V6        0.1254
## V11       0.1234
## V13       0.1278
## V14       0.1287
## V17       0.1343
## V19       0.1279
## V27       0.1253
## V33       0.1283
## V37       0.1298
## V45       0.1311</code></pre>
<p>The covariate values and estimated subgroups can be directly used by the <code><a href="../reference/summarize.subgroups.html">summarize.subgroups()</a></code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">comp2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/summarize.subgroups.html">summarize.subgroups</a></span>(x, <span class="dt">subgroup =</span> subgrp.model<span class="op">$</span>benefit.scores <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)</code></pre></div>
</div>
</div>
<div id="validating-subgroup-identification-models" class="section level2">
<h2 class="hasAnchor">
<a href="#validating-subgroup-identification-models" class="anchor"></a>Validating Subgroup Identification Models</h2>
<div id="overview-2" class="section level3">
<h3 class="hasAnchor">
<a href="#overview-2" class="anchor"></a>Overview</h3>
<p>An important aspect of estimating the impact of estimated subgroups is obtaining estimates of the treatment effect within the estimated subgroups. Ideally, the treatment should have a positive impact within the subgroup of patients who are recommended to the treatment and the control should have a positive impact within the subgroup of patients who were not recommended the treatment.</p>
<p>Since our estimated subgroups are conditional on observing the outcomes of the patients, taking the average outcomes by treatment status within each subgroup to estimate the treatment effects within subgroups will yield biased and typically overly-optimistic estimates. Instead, we need to use resampling-based procedures to estimate these effects reliably. There are two methods for subgroup treatment effect estimation. Both methods are available using the <code><a href="../reference/validate.subgroup.html">validate.subgroup()</a></code> function.</p>
</div>
<div id="repeated-trainingtest-splitting" class="section level3">
<h3 class="hasAnchor">
<a href="#repeated-trainingtest-splitting" class="anchor"></a>Repeated Training/Test Splitting</h3>
<p>The first method is prediction-based. For each replication in this procedure, data are randomly partitioned into a training and testing portion. For each replocation the subgroup identification model is estimated using the training procedure and the subgroup treatment effects are estimated using the test data. This method requires two arguments to be passed to <code><a href="../reference/validate.subgroup.html">validate.subgroup()</a></code>. The first argument is <code>B</code>, the number of replications and the second argument is <code>train.fraction</code>, which is the proportion of all samples which will be used for training (hence <code>1 - train.fraction</code> is the portion of samples used for testing).</p>
<p>The main object which needs to be passed to <code><a href="../reference/validate.subgroup.html">validate.subgroup()</a></code> is a fitted object returned by the <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code>. Note that in order to validate a fitted object from <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code>, the model must be fit with the <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code> <code>retcall</code> set to <code>TRUE</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># check that the object is an object returned by fit.subgroup()</span>
<span class="kw">class</span>(subgrp.model.eff)</code></pre></div>
<pre><code>## [1] "subgroup_fitted"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">validation.eff &lt;-<span class="st"> </span><span class="kw"><a href="../reference/validate.subgroup.html">validate.subgroup</a></span>(subgrp.model.eff, 
                                 <span class="dt">B =</span> 25L,  <span class="co"># specify the number of replications</span>
                                 <span class="dt">method =</span> <span class="st">"training_test_replication"</span>,
                                 <span class="dt">train.fraction =</span> <span class="fl">0.75</span>)

validation.eff</code></pre></div>
<pre><code>## family:  gaussian 
## loss:    sq_loss_lasso 
## method:  weighting 
## 
## validation method:  training_test_replication 
## iterations:  25 
## 
## Average Test Set Outcomes:
##                              Recommended 0
## Received 0   -7.0823 (SE = 3.0084, n = 50)
## Received 1 -15.235 (SE = 2.5161, n = 73.6)
##                                Recommended 1
## Received 0 -18.5781 (SE = 2.3983, n = 52.72)
## Received 1 -10.1248 (SE = 2.8927, n = 73.68)
## 
##    0 effect among recommended 0    1 effect among recommended 1 
## 8.1527 (SE = 4.8231, n = 123.6) 8.4532 (SE = 3.9401, n = 126.4)</code></pre>
</div>
<div id="bootstrap-bias-correction" class="section level3">
<h3 class="hasAnchor">
<a href="#bootstrap-bias-correction" class="anchor"></a>Bootstrap Bias Correction</h3>
<p>The second method is a bootstrap-based method which seeks to estimate the bias in the estimates of the subgroup treatment effects and then corrects for this bias (Harrell, et al. 1996).</p>
<ul>
<li>
<p>For a statistic <span class="math inline">\(d\)</span> let <span class="math inline">\(d_{train}(X)\)</span> be the statistic estimated with the training data and evaluated on data <span class="math inline">\(X\)</span> and <span class="math inline">\(d_{b}(X)\)</span> be the statistics estimated using a bootstrap sample <span class="math inline">\(X_b\)</span> (samples with replacement from <span class="math inline">\(X\)</span>) and evaluated on <span class="math inline">\(X\)</span></p>
</li>
<li><p>The bootstrap estimate of the amount of bias with regards to the statistic <span class="math inline">\(d\)</span> is <span class="math display">\[
{bias}(X) = \frac{1}{B}\sum_{b = 1}^B d_b(X_b) - d_b(X)
\]</span></p></li>
<li><p>Then a bias-corrected estimate of the statistic <span class="math inline">\(d\)</span> is <span class="math display">\[d_{train}(X) - {bias}(X)\]</span></p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">validation3 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/validate.subgroup.html">validate.subgroup</a></span>(subgrp.model, 
                                 <span class="dt">B =</span> 25L,  <span class="co"># specify the number of replications</span>
                                 <span class="dt">method =</span> <span class="st">"boot_bias_correction"</span>)

validation3</code></pre></div>
<pre><code>## family:  gaussian 
## loss:    sq_loss_lasso 
## method:  weighting 
## 
## validation method:  boot_bias_correction 
## iterations:  25 
## 
## Average Bootstrap Bias-Corrected Outcomes:
##                                 Recommended 0
## Received 0 -11.4236 (SE = 1.5942, n = 193.04)
## Received 1 -17.2373 (SE = 1.5124, n = 267.76)
##                                Recommended 1
## Received 0 -14.9861 (SE = 1.8001, n = 212.6)
## Received 1  -9.9044 (SE = 1.5114, n = 326.6)
## 
##    0 effect among recommended 0    1 effect among recommended 1 
## 5.8138 (SE = 2.2454, n = 460.8) 5.0817 (SE = 2.4106, n = 539.2)</code></pre>
</div>
<div id="plotting-validated-models" class="section level3">
<h3 class="hasAnchor">
<a href="#plotting-validated-models" class="anchor"></a>Plotting Validated Models</h3>
<p>The results for each of the iterations of either the bootstrap of the training and testing partitioning procedure can be plotted using the <code>plot()</code> function similarly to how the <code>plot()</code> function can be used for fitted objects from <code><a href="../reference/fit.subgroup.html">fit.subgroup()</a></code>. Similarly, boxplots, density plots, and interaction plots are all available through the <code>type</code> argument:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(validation)</code></pre></div>
<pre><code>## Warning: Removed 4 rows containing non-finite values (stat_boxplot).</code></pre>
<p><img src="usage_of_the_personalized_package_files/figure-html/plot_ex_model_1a-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(validation, <span class="dt">type =</span> <span class="st">"density"</span>)</code></pre></div>
<pre><code>## Warning: Removed 4 rows containing non-finite values (stat_density).</code></pre>
<p><img src="usage_of_the_personalized_package_files/figure-html/plot_ex_model_1b-1.png" width="672"></p>
<p>Multiple validated models can be visually compared using the <code><a href="../reference/plotCompare.html">plotCompare()</a></code> function, which offers the same plotting options as the <code><a href="../reference/plot.html">plot.subgroup_validated()</a></code> function. Here we compare the model fitted using <code>sq_loss_lasso</code> to the one fitted using <code>sq_loss_lasso</code> and efficiency augmentation:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plotCompare.html">plotCompare</a></span>(validation, validation.eff)</code></pre></div>
<pre><code>## Warning: Removed 4 rows containing non-finite values (stat_boxplot).</code></pre>
<p><img src="usage_of_the_personalized_package_files/figure-html/plot_compare_ex3-1.png" width="672"></p>
<p>We can see above that the model with efficiency augmentation finds subgroups with more impactful treatment effects.</p>
</div>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction-to-personalized">Introduction to <code>personalized</code></a></li>
      <li>
<a href="#quick-usage-reference">Quick Usage Reference</a><ul class="nav nav-pills nav-stacked">
<li><a href="#creating-and-checking-propensity-score-model">Creating and Checking Propensity Score Model</a></li>
      <li><a href="#fitting-subgroup-identification-model">Fitting Subgroup Identification Model</a></li>
      <li><a href="#evaluating-effect-of-subgroup-identification-model">Evaluating Effect of Subgroup Identification Model</a></li>
      </ul>
</li>
      <li>
<a href="#user-guide">User Guide</a><ul class="nav nav-pills nav-stacked">
<li><a href="#overview">Overview</a></li>
      <li><a href="#creating-and-checking-a-propensity-score-model">Creating and Checking a propensity Score Model</a></li>
      <li><a href="#fitting-subgroup-identification-models">Fitting Subgroup Identification Models</a></li>
      <li><a href="#validating-subgroup-identification-models">Validating Subgroup Identification Models</a></li>
      </ul>
</li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Jared Huling.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
